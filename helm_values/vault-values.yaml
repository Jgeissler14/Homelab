---
global:
  enabled: true
  tlsDisable: true
injector:
  # True if you want to enable vault agent injection
  # When working w/CSI providers when testing turn off.
  enabled: true
  # port the injector should listen on
  port: 8080

  # Vault injector resesource request and limits toggle
  resources:
    requests:
      memory: 256Mi
      cpu: 250m
    limits:
      memory: 256Mi
      cpu: 250m
  # Extra labels to attach to the agent-injector
  # This should be a YAML map of the labels to apply to the injector
  extraLabels:
    k8s.guidehouse.io/org: gh-aiaa
    k8s.guidehouse.io/team: ccl-ttb
    k8s.guidehouse.io/group: gh-ccl-ttb-admins
    k8s.guidehouse.io/tier: dev
    k8s.guidehouse.io/env: dev-paas
    k8s.guidehouse.io/class: policy-management

  # Cert-manager issues certs for the injector
  certs:
    # secretName is the name of the secret that has the TLS certificate and
    # private key to serve the injector webhook. If this is null, then the
    # injector will default to its automatic management mode that will assign
    # a service account to the injector to generate its own certificates.
    secretName: null

    # caBundle is a base64-encoded PEM-encoded certificate bundle for the CA
    # that signed the TLS certificate that the webhook serves. This must be set
    # if secretName is non-null unless an external service like cert-manager is
    # keeping the caBundle updated.
    caBundle: ""

    # certName and keyName are the names of the files within the secret for
    # the TLS cert and private key, respectively. These have reasonable
    # defaults but can be customized if necessary.
    certName: tls.crt
    keyName: tls.key

server: 
  # If not set to true, Vault server will not be installed.
  enabled: true
  image:
    repository: "vault"
    tag: "1.12.0"
    pullPolicy: IfNotPresent

  # Configure the logging verbosity for the Vault server.
  # log levels: trace, debug, info, warn, error
  logLevel: "error"

  # Configure the logging format for the Vault server.
  # Supported log formats include: standard, json
  logFormat: "standard"

  # Vault server resesource request and limits toggle
  resources:
    requests:
      memory: 256Mi
      cpu: 250m
    limits:
      memory: 256Mi
      cpu: 250m

#This section is double commented - letsencyrpt self sign to be used here when vault deployed and graduated
  # Ingress allows ingress services to be created to allow external access
  # from Kubernetes to access Vault pods.
  # If deployment is on OpenShift, the following block is ignored.
  # In order to expose the service, use the route section below
  # ingress:
  #   enabled: true
  #   labels:
  #     traffic: external
  #   annotations:
  #     kubernetes.io/ingress.class: nginx
  #     kubernetes.io/tls-acme: "true"
  #     certmanager.k8s.io/issuer: vault-letsencrypt-dns01-staging
  #     cert-manager.io/common-name: vault.guidehouse.cloud
  #     nginx.ingress.kubernetes.io/ssl-redirect: "true"
  #     nginx.ingress.kubernetes.io/force-ssl-redirect: "true"

  #     # kubernetes.io/ingress.class: nginx
  #     # kubernetes.io/tls-acme: "true"

  #   # Optionally use ingressClassName instead of deprecated annotation.
  #   # See: https://kubernetes.io/docs/concepts/services-networking/ingress/#deprecated-annotation
  #   ingressClassName: "external-nginx"

  #   # As of Kubernetes 1.19, all Ingress Paths must have a pathType configured. The default value below should be sufficient in most cases.
  #   # See: https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types for other possible values.
  #   pathType: Prefix

  #   # When HA mode is enabled and K8s service registration is being used,
  #   # configure the ingress to point to the Vault active service.
  #   activeService: true
  #   hosts:
  #     - host: vault.guidehouse.cloud
  #       paths: []
  #   ## Extra paths to prepend to the host configuration. This is useful when working with annotation based services.
  #   extraPaths: []
  #   # - path: /*
  #   #   backend:
  #   #     service:
  #   #       name: ssl-redirect
  #   #       port:
  #   #         number: use-annotation
  #   tls:
  #    - secretName: wildcard-vault-guidehouse-cloud-tls
  #      hosts:
  #        - vault.guidehouse.cloud

 # Used to define custom readinessProbe settings
  readinessProbe:
    path: "/v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204"
    # When a probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 2
    # Number of seconds after the container has started before probe initiates
    initialDelaySeconds: 5
    # How often (in seconds) to perform the probe
    periodSeconds: 5
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # Number of seconds after which the probe times out.
    timeoutSeconds: 3
  # Used to enable a livenessProbe for the pods
  livenessProbe:
    enabled: false
    path: "/v1/sys/health?standbyok=true"
    # When a probe fails, Kubernetes will try failureThreshold times before giving up
    failureThreshold: 2
    # Number of seconds after the container has started before probe initiates
    initialDelaySeconds: 60
    # How often (in seconds) to perform the probe
    periodSeconds: 5
    # Minimum consecutive successes for the probe to be considered successful after having failed
    successThreshold: 1
    # Number of seconds after which the probe times out.
    timeoutSeconds: 3

  # Used to define commands to run after the pod is ready.
  # Automated initialization of vault
  # postStart:
  # - /bin/sh
  # - -c
  # - sleep 5 && cp /vault/userconfig/bootstrap.sh /tmp/gh-config/bootstrap.sh && chmod +x /tmp/gh-config/bootstrap.sh 

  # extraSecretEnvironmentVars is a list of extra environment variables to set with the stateful set.
  # These variables take value from existing Secret objects.
  extraSecretEnvironmentVars:
    - secretName: admin-id
      secretKey: id
      envName: AWS_ACCESS_KEY_ID
    - secretName: admin-id
      secretKey: secret
      envName: AWS_SECRET_ACCESS_KEY
    - secretName: admin-id
      secretKey: kms
      envName: VAULT_AWSKMS_SEAL_KEY_ID

  # volumes is a list of volumes made available to all containers.
  volumes:
    - name: post-install
      emptyDir: {}     
    - name: vault-bootstrap
      configMap:
        name: vault-bootstrap
        defaultMode: 0744
    # - name: secrets-store-inline
    #   csi:
    #     driver: secrets-store.csi.k8s.io
    #     readOnly: true
    #     volumeAttributes:
    #       secretProviderClass: aws-admin-id-secret
  # volumeMounts is a list of volumeMounts for the main server container.
  volumeMounts:
    - mountPath: /tmp/gh-config
      name: post-install
    - mountPath: /vault/userconfig
      name: vault-bootstrap
    # - mountPath: /mnt/secrets-store
    #   name: secrets-store-inline
    #   readOnly: true

  # Labels to attach to the server pods 
  extraLabels:
    k8s.guidehouse.io/org: gh-aiaa
    k8s.guidehouse.io/team: ccl-ttb
    k8s.guidehouse.io/group: gh-ccl-ttb-admins
    k8s.guidehouse.io/tier: dev
    k8s.guidehouse.io/env: dev-paas
    k8s.guidehouse.io/class: policy-manager


  # Enables a headless service to be used by the Vault Statefulset
  service:
    enabled: true
    # Enable or disable the vault-active service, which selects Vault pods that
    # have labelled themselves as the cluster leader with `vault-active: "true"`
    active:
      enabled: false
    # Enable or disable the vault-standby service, which selects Vault pods that
    # have labelled themselves as a cluster follower with `vault-active: "false"`
    standby:
      enabled: true
    # clusterIP controls whether a Cluster IP address is attached to the
    # Vault service within Kubernetes.  By default, the Vault service will
    # be given a Cluster IP address, set to None to disable.  When disabled
    # Kubernetes will create a "headless" service.  Headless services can be
    # used to communicate with pods directly through DNS instead of a round-robin
    # load balancer.
    # clusterIP: None

    # Configures the service type for the main Vault service.  Can be ClusterIP
    # or NodePort.
    type: ClusterIP

    # Do not wait for pods to be ready
    publishNotReadyAddresses: true

    # The externalTrafficPolicy can be set to either Cluster or Local
    # and is only valid for LoadBalancer and NodePort service types.
    # The default value is Cluster.
    # ref: https://kubernetes.io/docs/concepts/services-networking/service/#external-traffic-policy
    externalTrafficPolicy: Cluster

    # If type is set to "NodePort", a specific nodePort value can be configured,
    # will be random if left blank.
    #nodePort: 30000

    # When HA mode is enabled
    # If type is set to "NodePort", a specific nodePort value can be configured,
    # will be random if left blank.
    #activeNodePort: 30001

    # When HA mode is enabled
    # If type is set to "NodePort", a specific nodePort value can be configured,
    # will be random if left blank.
    #standbyNodePort: 30002

    # Port on which Vault server is listening
    port: 8200
    # Target port to which the service should be mapped to
    targetPort: 8200
    # Extra annotations for the service definition. This can either be YAML or a
    # YAML-formatted multi-line templated string map of the annotations to apply
    # to the service.
    annotations: {}


  # This configures the Vault Statefulset to create a PVC for data
  # storage when using the file or raft backend storage engines.
  # See https://www.vaultproject.io/docs/configuration/storage/index.html to know more
  dataStorage:
    enabled: true
    size: 10Gi
    storageClass: null
    accessMode: ReadWriteOnce

  # This configures the Vault Statefulset to create a PVC for audit
  # logs.  Once Vault is deployed, initialized and unseal, Vault must
  # be configured to use this for audit logs.  This will be mounted to
  # /vault/audit
  # See https://www.vaultproject.io/docs/audit/index.html to know more
  auditStorage:
    enabled: false

  # Mode in which the vault server is meant to configure upon deployment
  # options include (maybe subject to futher development if changed):
  # dev.enabled.true
  # standalone.enabled.true
  # ha.enabled.true
  # dev:
  #   enabled: true
  standalone:
    enabled: "-"
    config: |
      ui = true

      listener "tcp" {
        tls_disable = "true"
        address = "[::]:8200"
        cluster_address = "[::]:8201"
      }
      storage "file" {
        path = "/vault/data"
      }

      
# seal "awskms" {
#   region     = "us-east-1"
#   access_key = "AWS_ACCESS_KEY_ID"
#   secret_key = "AWS_SECRET_ACCESS_KEY"
#   kms_key_id = "VAULT_AWSKMS_SEAL_KEY_ID"
# }


  # ha:
  #   enabled: false
  #   replicas: 1
  #   raft:
  #     enabled: true
  #     config: |
  #       ui = true
  #       listener "tcp" {
  #         tls_disable = 1
  #         address = "[::]:8200"
  #         cluster_address = "[::]:8201"
  #       }
  #       storage "raft" {
  #         path = "/vault/data"
  #       }
  #       service_registration "kubernetes" {}

  # # Definition of the serviceAccount used to run Vault.
  # # These options are also used when using an external Vault server to validate
  # # Kubernetes tokens.
  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

# Vault UI
ui:
  # True if you want to create a Service entry for the Vault UI.
  # serviceType can be used to control the type of service created. For
  # example, setting this to "LoadBalancer" will create an external load
  # balancer (for supported K8S installations) to access the UI.
  enabled: true
  publishNotReadyAddresses: true
  # The service should only contain selectors for active Vault pod
  activeVaultPodOnly: false
  serviceType: "LoadBalancer"
  serviceNodePort: null
  externalPort: 8200
  targetPort: 8200

  # The externalTrafficPolicy can be set to either Cluster or Local
  # and is only valid for LoadBalancer and NodePort service types.
  # The default value is Cluster.
  # ref: https://kubernetes.io/docs/concepts/services-networking/service/#external-traffic-policy
  externalTrafficPolicy: Cluster

  #loadBalancerSourceRanges:
  #   - 10.0.0.0/16
  #   - 1.78.23.3/32

  # loadBalancerIP:

  # Extra annotations to attach to the ui service
  # This can either be YAML or a YAML-formatted multi-line templated string map
  # of the annotations to apply to the ui service
  annotations:
    external-dns.alpha.kubernetes.io/hostname: vault.guidehouse.cloud
    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:us-east-1:672108202355:certificate/c527cefb-4788-4d6c-aaa6-3811102c05d9"
    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443"
    service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy: "ELBSecurityPolicy-TLS-1-2-2017-01"
    service.beta.kubernetes.io/aws-load-balancer-type: "alb"
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http
  